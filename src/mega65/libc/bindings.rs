/* automatically generated by rust-bindgen 0.60.1 */

pub const ATTRIB_BLINK: u32 = 16;
pub const ATTRIB_REVERSE: u32 = 32;
pub const ATTRIB_UNDERLINE: u32 = 128;
pub const ATTRIB_HIGHLIGHT: u32 = 64;
pub const COLOUR_BLACK: u32 = 0;
pub const COLOUR_WHITE: u32 = 1;
pub const COLOUR_RED: u32 = 2;
pub const COLOUR_CYAN: u32 = 3;
pub const COLOUR_PURPLE: u32 = 4;
pub const COLOUR_GREEN: u32 = 5;
pub const COLOUR_BLUE: u32 = 6;
pub const COLOUR_YELLOW: u32 = 7;
pub const COLOUR_ORANGE: u32 = 8;
pub const COLOUR_BROWN: u32 = 9;
pub const COLOUR_PINK: u32 = 10;
pub const COLOUR_GREY1: u32 = 11;
pub const COLOUR_DARKGREY: u32 = 11;
pub const COLOUR_GREY2: u32 = 12;
pub const COLOUR_GREY: u32 = 12;
pub const COLOUR_MEDIUMGREY: u32 = 12;
pub const COLOUR_LIGHTGREEN: u32 = 13;
pub const COLOUR_LIGHTBLUE: u32 = 14;
pub const COLOUR_GREY3: u32 = 15;
pub const COLOUR_LIGHTGREY: u32 = 15;
pub const KEYMOD_RSHIFT: u32 = 1;
pub const KEYMOD_LSHIFT: u32 = 2;
pub const KEYMOD_CTRL: u32 = 4;
pub const KEYMOD_MEGA: u32 = 8;
pub const KEYMOD_ALT: u32 = 16;
pub const KEYMOD_NOSCRL: u32 = 32;
pub const KEYMOD_CAPSLOCK: u32 = 64;
pub const BOX_STYLE_NONE: u32 = 0;
pub const BOX_STYLE_INNER: u32 = 1;
pub const BOX_STYLE_MID: u32 = 2;
pub const BOX_STYLE_OUTER: u32 = 3;
pub const BOX_STYLE_ROUND: u32 = 4;
pub const HLINE_STYLE_TOP_THIN: u32 = 99;
pub const HLINE_STYLE_BTM_THIN: u32 = 100;
pub const HLINE_STYLE_TOP_NORMAL: u32 = 119;
pub const HLINE_STYLE_BTM_NORMAL: u32 = 111;
pub const HLINE_STYLE_TOP1_8: u32 = 69;
pub const HLINE_STYLE_TOP3_8: u32 = 68;
pub const HLINE_STYLE_BTM1_8: u32 = 82;
pub const HLINE_STYLE_BTM3_8: u32 = 70;
pub const HLINE_STYLE_MID: u32 = 64;
pub const HLINE_STYLE_CHECKER: u32 = 104;
pub const VLINE_STYLE_LEFT_NORMAL: u32 = 116;
pub const VLINE_STYLE_RIGHT_NORMAL: u32 = 106;
pub const VLINE_STYLE_MID: u32 = 66;
pub const VLINE_STYLE_CHECKER: u32 = 92;
pub const CINPUT_ACCEPT_NUMERIC: u32 = 1;
pub const CINPUT_ACCEPT_LETTER: u32 = 2;
pub const CINPUT_ACCEPT_ALL: u32 = 4;
pub const CINPUT_NO_AUTOTRANSLATE: u32 = 8;
pub const CINPUT_ACCEPT_ALPHA: u32 = 3;
pub const TARGET_UNKNOWN: u32 = 0;
pub const TARGET_MEGA65R1: u32 = 1;
pub const TARGET_MEGA65R2: u32 = 2;
pub const TARGET_MEGA65R3: u32 = 3;
pub const TARGET_MEGAPHONER1: u32 = 33;
pub const TARGET_NEXYS4: u32 = 64;
pub const TARGET_NEXYS4DDR: u32 = 65;
pub const TARGET_NEXYS4DDRWIDGET: u32 = 66;
pub const TARGET_WUKONG: u32 = 253;
pub const TARGET_SIMULATION: u32 = 254;
pub const TEST_START: u32 = 240;
pub const TEST_SKIP: u32 = 241;
pub const TEST_PASS: u32 = 242;
pub const TEST_FAIL: u32 = 243;
pub const TEST_ERROR: u32 = 244;
pub const TEST_LOG: u32 = 253;
pub const TEST_SETNAME: u32 = 254;
pub const TEST_DONEALL: u32 = 255;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagRECT {
    pub left: ::core::ffi::c_uchar,
    pub top: ::core::ffi::c_uchar,
    pub right: ::core::ffi::c_uchar,
    pub bottom: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_tagRECT() {
    assert_eq!(
        ::core::mem::size_of::<tagRECT>(),
        4usize,
        concat!("Size of: ", stringify!(tagRECT))
    );
    assert_eq!(
        ::core::mem::align_of::<tagRECT>(),
        1usize,
        concat!("Alignment of ", stringify!(tagRECT))
    );
    fn test_field_left() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<tagRECT>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).left) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(tagRECT),
                "::",
                stringify!(left)
            )
        );
    }
    test_field_left();
    fn test_field_top() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<tagRECT>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).top) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(tagRECT),
                "::",
                stringify!(top)
            )
        );
    }
    test_field_top();
    fn test_field_right() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<tagRECT>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).right) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(tagRECT),
                "::",
                stringify!(right)
            )
        );
    }
    test_field_right();
    fn test_field_bottom() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<tagRECT>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(tagRECT),
                "::",
                stringify!(bottom)
            )
        );
    }
    test_field_bottom();
}
pub type RECT = tagRECT;
extern "C" {
    #[doc = " \\m65libsummary{conionit}{Initialises the library internal state}"]
    #[doc = "\\m65libsyntax    {void conioinit(void)}"]
    #[doc = "\\m65libremarks{This must be called before using any conio library function.}"]
    pub fn conioinit();
}
extern "C" {
    #[doc = " \\m65libsummary{togglecase}{Set lower case character set}"]
    #[doc = "\\m65libsyntax    {void setlowercase(void)}"]
    pub fn setlowercase();
}
extern "C" {
    #[doc = " \\m65libsummary{togglecase}{Set upper case character set}"]
    #[doc = "\\m65libsyntax    {void setuppercase(void)}"]
    pub fn setuppercase();
}
extern "C" {
    #[doc = " \\m65libsummary{setscreenaddr}{Sets the screen RAM start address}"]
    #[doc = "\\m65libsyntax    {void setscreenaddr(long addr);}"]
    #[doc = "\\m65libparam     {addr}{The address to set as start of screen RAM}"]
    #[doc = "\\m65example   {"]
    #[doc = "setscreenaddr(0x48000UL);"]
    #[doc = "}"]
    #[doc = "\\m65libremarks{No bounds check is performed on the selected address}"]
    pub fn setscreenaddr(addr: ::core::ffi::c_long);
}
extern "C" {
    #[doc = " \\m65libsummary{getscreenaddr}{Returns the screen RAM start address}"]
    #[doc = "\\m65libsyntax    {long getscreenaddr(void);}"]
    #[doc = "\\m65libretval    {The current screen RAM address start address.}"]
    pub fn getscreenaddr() -> ::core::ffi::c_long;
}
extern "C" {
    #[doc = " \\m65libsummary{setcolramoffset}{Sets the color RAM start offset value}"]
    #[doc = "\\m65libsyntax    {void setcolramoffset(long offset);}"]
    #[doc = "\\m65libparam     {addr}{The offset from the beginning of the color RAM address ($FF80000)}"]
    #[doc = "\\m65libremarks{No bounds check is performed on the resulting address. Do not exceed the available Color RAM size}"]
    pub fn setcolramoffset(addr: ::core::ffi::c_uint);
}
extern "C" {
    #[doc = " \\m65libsummary{getcolramoffset}{Returns the color RAM start offset value}"]
    #[doc = "\\m65libsyntax    {long getscreenaddr(void);}"]
    #[doc = "\\m65libretval    {The current color RAM start offset value.}"]
    pub fn getcolramoffset() -> ::core::ffi::c_uint;
}
extern "C" {
    #[doc = " \\m65libsummary{setcharsetaddr}{Sets the character set start address}"]
    #[doc = "\\m65libsyntax    {void setcharsetaddr(long addr);}"]
    #[doc = "\\m65libparam     {addr}{The address to set as start of character set}"]
    #[doc = "\\m65libremarks   {No bounds check is performed on the selected address}"]
    pub fn setcharsetaddr(addr: ::core::ffi::c_long);
}
extern "C" {
    #[doc = " \\m65libsummary{getcharsetaddr}{Returns the current character set start address}"]
    #[doc = "\\m65libsyntax    {long getscreenaddr(void);}"]
    #[doc = "\\m65libretval    {The current character set start address.}"]
    pub fn getcharsetaddr() -> ::core::ffi::c_long;
}
extern "C" {
    #[doc = "\\m65libsummary{clrscr}{Clear the text screen. }"]
    #[doc = "\\m65libsyntax    {void clrscr(void)}"]
    #[doc = "\\m65example   {"]
    #[doc = "textcolor(COLOUR_WHITE);"]
    #[doc = "clrscr();"]
    #[doc = "}"]
    #[doc = "\\m65libremarks{Color RAM will be cleared with current text color}"]
    pub fn clrscr();
}
extern "C" {
    #[doc = " \\m65libsummary{getscreensize}{Returns the dimensions of the text screen}"]
    #[doc = "\\m65libsyntax    {void getscreensize(unsigned char* width, unsigned char* height)}"]
    #[doc = "\\m65libparam     {width}{Pointer to location where width will be returned}"]
    #[doc = "\\m65libparam     {height}{Pointer to location where height will be returned}"]
    pub fn getscreensize(width: *mut ::core::ffi::c_uchar, height: *mut ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{setscreensize}{Sets the dimensions of the text screen}"]
    #[doc = "\\m65libsyntax    {void setscreensize(unsigned char width, unsigned char height)}"]
    #[doc = "\\m65libparam     {width}{The width in columns (40 or 80)}"]
    #[doc = "\\m65libparam     {height}{The height in rows (25 or 50)}"]
    #[doc = "\\m65libremarks   {Currently only 40/80 and 25/50 are accepted. Other values are ignored.}"]
    pub fn setscreensize(width: ::core::ffi::c_uchar, height: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{set16bitcharmode}{Sets or clear the 16-bit character mode}"]
    #[doc = "\\m65libsyntax    {void set16bitcharmode(unsigned char f)}"]
    #[doc = "\\m65libparam     {f}{Set true to set the 16-bit character mode}"]
    #[doc = "\\m65libremarks   {This will trigger a video parameter reset if HOTREG is ENABLED. See sethotregs function.}"]
    pub fn set16bitcharmode(f: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{sethotregs}{Sets or clear the hot-register behavior of the VIC-IV chip.}"]
    #[doc = "\\m65libsyntax    {void set16bitcharmode(unsigned char f)}"]
    #[doc = "\\m65libparam     {f}{Set true to enable the hotreg behavior}"]
    #[doc = "\\m65libremarks   {When this mode is ENABLED a video mode reset will be triggered when touching $D011, $D016, $D018, $D031"]
    #[doc = "or the VIC-II bank bits of $DD00. }"]
    pub fn sethotregs(f: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{setextendedattrib}{Sets or clear the VIC-III extended attributes mode to support blink, underline, bold"]
    #[doc = "and highlight.} \\m65libsyntax    {void setextendedattrib(unsigned char f)} \\m65libparam     {f}{Set true to set the"]
    #[doc = "extended attributes mode}"]
    pub fn setextendedattrib(f: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{togglecase}{Toggle the current character set case}"]
    #[doc = "\\m65libsyntax    {void togglecase(void)}"]
    pub fn togglecase();
}
extern "C" {
    #[doc = " \\m65libsummary{bordercolor}{Sets the current border color}"]
    #[doc = "\\m65libsyntax    {void bordercolor(unsigned char c)}"]
    #[doc = "\\m65libparam     {c}{The color to set}"]
    pub fn bordercolor(c: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{bgcolor}{Sets the current screen (background) color}"]
    #[doc = "\\m65libsyntax    {void bgcolor(unsigned char c)}"]
    #[doc = "\\m65libparam     {c}{The color to set}"]
    pub fn bgcolor(c: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{textcolor}{Sets the current text color}"]
    #[doc = "\\m65libsyntax    {void textcolor(unsigned char c)}"]
    #[doc = "\\m65libparam     {c}{The color to set}"]
    #[doc = "\\m65libremarks   {This function preserves attributes in the upper 4-bits if extended attributes are enabled. See"]
    #[doc = "setextendedattrib. }"]
    pub fn textcolor(c: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{revers}{Enable the reverse attribute}"]
    #[doc = "\\m65libsyntax    {void revers(unsigned char c)}"]
    #[doc = "\\m65libparam     {enable}{0 to disable, 1 to enable}"]
    #[doc = "\\m65libremarks   {Extended attributes mode must be active. See setextendedattrib.}"]
    pub fn revers(enable: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{highlight}{Enable the highlight attribute}"]
    #[doc = "\\m65libsyntax    {void highlight(unsigned char c)}"]
    #[doc = "\\m65libparam     {enable}{0 to disable, 1 to enable}"]
    #[doc = "\\m65libremarks   {Extended attributes mode must be active. See setextendedattrib.}"]
    pub fn highlight(enable: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{blink}{Enable the blink attribute}"]
    #[doc = "\\m65libsyntax    {void blink(unsigned char c)}"]
    #[doc = "\\m65libparam     {enable}{0 to disable, 1 to enable}"]
    #[doc = "\\m65libremarks   {Extended attributes mode must be active. See setextendedattrib.}"]
    pub fn blink(enable: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{underline}{Enable the underline attribute}"]
    #[doc = "\\m65libsyntax    {void underline(unsigned char c)}"]
    #[doc = "\\m65libparam     {enable}{0 to disable, 1 to enable}"]
    #[doc = "\\m65libremarks   {Extended attributes mode must be active. See setextendedattrib.}"]
    pub fn underline(enable: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{altpal}{Enable the alternate-palette attribute}"]
    #[doc = "\\m65libsyntax    {void altpal(unsigned char c)}"]
    #[doc = "\\m65libparam     {enable}{0 to disable, 1 to enable}"]
    #[doc = "\\m65libremarks   {Extended attributes mode must be active. See setextendedattrib.}"]
    pub fn altpal(enable: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{clearattr}{Clear all text attributes}"]
    #[doc = "\\m65libsyntax    {void clearattr())}"]
    #[doc = "\\m65libremarks   {Extended attributes mode must be active. See setextendedattrib.}"]
    pub fn clearattr();
}
extern "C" {
    #[doc = " \\m65libsummary{cellcolor}{Sets the color of a character cell}"]
    #[doc = "\\m65libsyntax    {void cellcolor(unsigned char x, unsigned char y, unsigned char c)}"]
    #[doc = "\\m65libparam     {x}{The cell X-coordinate}"]
    #[doc = "\\m65libparam     {y}{The cell Y-coordinate}"]
    #[doc = "\\m65libparam     {c}{The color to set}"]
    #[doc = "\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn cellcolor(x: ::core::ffi::c_uchar, y: ::core::ffi::c_uchar, c: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{setpalbank}{Set current text/bitmap palette bank (BTPALSEL).}"]
    #[doc = "\\m65libsyntax    {void setpalbank(unsigned char bank)}"]
    #[doc = "\\m65libparam     {bank}{The palette bank to set. Valid values are 0, 1, 2 or 3.}"]
    #[doc = "\\m65libremarks   {Use setpalbanka to set alternate text/bitmap palette}"]
    pub fn setpalbank(bank: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{setpalbanka}{Set alternate text/bitmap palette bank.}"]
    #[doc = "\\m65libsyntax    {void setpalbanka(unsigned char bank)}"]
    #[doc = "\\m65libparam     {bank}{The palette bank to set. Valid values are 0, 1, 2 or 3.}"]
    #[doc = "\\m65libremarks   {Use setpalbank to set main text/bitmap palette}"]
    pub fn setpalbanka(bank: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{getpalbank}{Get selected text/bitmap palette bank.}"]
    #[doc = "\\m65libsyntax    {unsigned char getpalbank(void)}"]
    #[doc = "\\m65libremarks   {Use getpalbanka to get alternate text/bitmap selected palette}"]
    #[doc = "\\m65libretval    {The current selected main text/bitmap palette bank.}"]
    pub fn getpalbank() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{getpalbanka}{Get selected alternate text/bitmap palette bank.}"]
    #[doc = "\\m65libsyntax    {unsigned char getpalbanka(void)}"]
    #[doc = "\\m65libremarks   {Use getpalbank to get main text/bitmap selected palette}"]
    #[doc = "\\m65libretval    {The current selected alternate text/bitmap palette bank.}"]
    pub fn getpalbanka() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{setmapedpal}{Set maped-in palette bank at $D100-$D3FF.}"]
    #[doc = "\\m65libsyntax    {void setmapedpal(unsigned char bank)}"]
    #[doc = "\\m65libparam     {bank}{The palette bank to map-in. Valid values are 0, 1, 2 or 3.}"]
    pub fn setmapedpal(bank: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{getmapedpal}{Get maped-in  palette bank at $D100-$D3FF.}"]
    #[doc = "\\m65libsyntax    {unsigned char getmapedpal(void)}"]
    pub fn getmapedpal() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{setpalentry}{Set color entry for the maped-in palette}"]
    #[doc = "\\m65libsyntax    {void setpalentry(unsigned char c, unsigned char r, unsigned char g, unsigned char b)}"]
    #[doc = "\\m65libparam     {c}{The palette entry index (0-255)}"]
    #[doc = "\\m65libparam     {r}{The red component value}"]
    #[doc = "\\m65libparam     {g}{The green component value}"]
    #[doc = "\\m65libparam     {b}{The blue component value}"]
    #[doc = "\\m65libremarks   {Use setmapedmal to bank-in the palette to modify}"]
    pub fn setpalentry(
        c: ::core::ffi::c_uchar,
        r: ::core::ffi::c_uchar,
        g: ::core::ffi::c_uchar,
        b: ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\m65libsummary{fillrect}{Fill a rectangular area with character and color value}"]
    #[doc = "\\m65libsyntax    {void fillrect(const RECT *rc, unsigned char ch, unsigned char col)}"]
    #[doc = "\\m65libparam     {rc}{A RECT structure specifying the box coordinates}"]
    #[doc = "\\m65libparam     {ch}{A char code to fill the rectangle}"]
    #[doc = "\\m65libparam     {col}{The color to fill}"]
    #[doc = "\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn fillrect(rc: *const RECT, ch: ::core::ffi::c_uchar, col: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{box}{Draws a box with graphic characters}"]
    #[doc = "\\m65libsyntax    {void box(const RECT *rc, unsigned char color, unsigned char style, unsigned char clear, unsigned char"]
    #[doc = "shadow)} \\m65libparam     {rc}{A RECT structure specifying the box coordinates} \\m65libparam     {color}{The color to use"]
    #[doc = "for the graphic characters} \\m65libparam     {style}{The style for the box borders. Can be set to BOX_STYLE_NONE,"]
    #[doc = "BOX_STYLE_ROUNDED, BOX_STYLE_INNER, BOX_STYLE_OUTER, BOX_STYLE_MID } \\m65libparam     {clear}{Set to 1 to clear the box"]
    #[doc = "interior with the selected color} \\m65libparam     {shadow}{Set to 1 to draw a drop shadow} \\m65libremarks   {No screen"]
    #[doc = "bounds checks are performed; out of screen behavior is undefined }"]
    #[link_name = "\u{1}box"]
    pub fn box_(
        rc: *const RECT,
        color: ::core::ffi::c_uchar,
        style: ::core::ffi::c_uchar,
        clear: ::core::ffi::c_uchar,
        shadow: ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\m65libsummary{hline}{Draws an horizontal line.}"]
    #[doc = "\\m65libsyntax    {void hline(unsigned char x, unsigned char y, unsigned char len, unsigned char style)}"]
    #[doc = "\\m65libparam     {x}{The line start X-coordinate}"]
    #[doc = "\\m65libparam     {y}{The line start Y-coordinate}"]
    #[doc = "\\m65libparam     {len}{The line length}"]
    #[doc = "\\m65libparam     {style}{The style for the line. See HLINE_ constants for available styles. }"]
    #[doc = "\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn hline(
        x: ::core::ffi::c_uchar,
        y: ::core::ffi::c_uchar,
        len: ::core::ffi::c_uchar,
        style: ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\m65libsummary{vline}{Draws a vertical line.}"]
    #[doc = "\\m65libsyntax    {void vline(unsigned char x, unsigned char y, unsigned char len, unsigned char style)}"]
    #[doc = "\\m65libparam     {x}{The line start X-coordinate}"]
    #[doc = "\\m65libparam     {y}{The line start Y-coordinate}"]
    #[doc = "\\m65libparam     {len}{The line length}"]
    #[doc = "\\m65libparam     {style}{The style for the line. See VLINE_ constants for available styles. }"]
    #[doc = "\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn vline(
        x: ::core::ffi::c_uchar,
        y: ::core::ffi::c_uchar,
        len: ::core::ffi::c_uchar,
        style: ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\m65libsummary{gohome}{Set the current position at home (0,0 coordinate)}"]
    #[doc = "\\m65libsyntax    {void gohome(void)}"]
    pub fn gohome();
}
extern "C" {
    #[doc = " \\m65libsummary{gotoxy}{Set the current position at X,Y coordinates}"]
    #[doc = "\\m65libsyntax    {void gotoxy(unsigned char x, unsigned char y)}"]
    #[doc = "\\m65libparam     {x}{The new X-coordinate}"]
    #[doc = "\\m65libparam     {y}{The new Y-coordinate}"]
    #[doc = "\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn gotoxy(x: ::core::ffi::c_uchar, y: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{gotox}{Set the current position X-coordinate}"]
    #[doc = "\\m65libsyntax    {void gotox(unsigned char x)}"]
    #[doc = "\\m65libparam     {x}{The new X-coordinate}"]
    #[doc = "\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn gotox(x: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{gotoy}{Set the current position Y-coordinate}"]
    #[doc = "\\m65libsyntax    {void gotoy(unsigned char y)}"]
    #[doc = "\\m65libparam     {y}{The new Y-coordinate}"]
    #[doc = "\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn gotoy(y: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{moveup}{Move current position up}"]
    #[doc = "\\m65libsyntax    {void moveup(unsigned char count)}"]
    #[doc = "\\m65libparam     {count}{The number of positions to move}"]
    #[doc = "\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn moveup(count: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{movedown}{Move current position down}"]
    #[doc = "\\m65libsyntax    {void movedown(unsigned char count)}"]
    #[doc = "\\m65libparam     {count}{The number of positions to move}"]
    #[doc = "\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn movedown(count: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{moveleft}{Move current position left}"]
    #[doc = "\\m65libsyntax    {void moveleft(unsigned char count)}"]
    #[doc = "\\m65libparam     {count}{The number of positions to move}"]
    #[doc = "\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn moveleft(count: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{moveright}{Move current position right}"]
    #[doc = "\\m65libsyntax    {void moveright(unsigned char count)}"]
    #[doc = "\\m65libparam     {count}{The number of positions to move}"]
    #[doc = "\\m65libremarks   {No screen bounds checks are performed; out of screen behavior is undefined }"]
    pub fn moveright(count: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{wherex}{Return the current position X coordinate}"]
    #[doc = "\\m65libsyntax    {unsigned char wherex(void)}"]
    #[doc = "\\m65libretval    {The current position X coordinate}"]
    pub fn wherex() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{wherey}{Return the current position Y coordinate}"]
    #[doc = "\\m65libsyntax    {unsigned char wherey(void)}"]
    #[doc = "\\m65libretval    {The current position Y coordinate}"]
    pub fn wherey() -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn petsciitoscreencode(c: ::core::ffi::c_char) -> ::core::ffi::c_char;
}
extern "C" {
    pub fn petsciitoscreencode_s(s: *mut ::core::ffi::c_char) -> *mut ::core::ffi::c_char;
}
extern "C" {
    #[doc = " \\m65libsummary{cputc}{Output a single screen code character to screen at current position}"]
    #[doc = "\\m65libsyntax    {void cputc(unsigned char c)}"]
    #[doc = "\\m65libparam     {c}{The screen code of the character to output}"]
    pub fn cputc(c: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{cputnc}{Output N copies of a character at current position}"]
    #[doc = "\\m65libsyntax    {void cputnc(unsigned char count, unsigned char c)}"]
    #[doc = "\\m65libparam     {c}{The screen code of the characters to output}"]
    #[doc = "\\m65libparam     {count}{The count of characters to print}"]
    pub fn cputnc(count: ::core::ffi::c_uchar, c: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{cputhex}{Output an hex-formatted number at current position}"]
    #[doc = "\\m65libsyntax    {void cputhex(long n, unsigned char prec)}"]
    #[doc = "\\m65libparam     {n}{The number to write}"]
    #[doc = "\\m65libparam     {prec}{The precision of the hex number, in digits. Leading zeros will be printed accordingly}"]
    #[doc = "\\m65libremarks   {The $ symbol will be automatically added at beginning of string}"]
    pub fn cputhex(n: ::core::ffi::c_long, prec: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{cputdec}{Output a decimal number at current position}"]
    #[doc = "\\m65libsyntax    {void cputdec(long n, unsigned char padding, unsigned char leadingZ)}"]
    #[doc = "\\m65libparam     {n}{The number to write}"]
    #[doc = "\\m65libparam     {padding}{The padding space to add before number}"]
    #[doc = "\\m65libparam     {leadingZ}{The leading zeros to print}"]
    pub fn cputdec(
        n: ::core::ffi::c_long,
        padding: ::core::ffi::c_uchar,
        leadingZ: ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\m65libsummary{cputs}{Output screen codes at current position}"]
    #[doc = "\\m65libsyntax    {void cputs(const unsigned char* s)}"]
    #[doc = "\\m65libparam     {s}{Am array of screen codes to print}"]
    #[doc = "\\m65libremarks   {This function works with screen codes only. To output ordinary ASCII/PETSCII strings,"]
    #[doc = "use the \"pcputs\" macro. No pointer check is performed.  If s is null or invalid, behavior is undefined. }"]
    pub fn cputs(s: *const ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{cputsxy}{Output multiple screen codes at X,Y coordinates}"]
    #[doc = "\\m65libsyntax    {void cputsxy (unsigned char x, unsigned char y, const unsigned char* s)}"]
    #[doc = "\\m65libparam     {x}{The X coordinate where string will be printed}"]
    #[doc = "\\m65libparam     {y}{The Y coordinate where string will be printed}"]
    #[doc = "\\m65libparam     {s}{An array of screen codes to print}"]
    #[doc = "\\m65libremarks   {This function works with screen codes only. To output ordinary ASCII/PETSCII strings,"]
    #[doc = "use the \"pcputsxy\" macro. No pointer check is performed.  If s is null or invalid, behavior is undefined. }"]
    pub fn cputsxy(
        x: ::core::ffi::c_uchar,
        y: ::core::ffi::c_uchar,
        s: *const ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\m65libsummary{cputcxy}{Output a single character at X,Y coordinates}"]
    #[doc = "\\m65libsyntax    {void cputcxy (unsigned char x, unsigned char y, unsigned char c)}"]
    #[doc = "\\m65libparam     {x}{The X coordinate where character will be printed}"]
    #[doc = "\\m65libparam     {y}{The Y coordinate where character will be printed}"]
    #[doc = "\\m65libparam     {c}{The screen code of the character to print}"]
    pub fn cputcxy(x: ::core::ffi::c_uchar, y: ::core::ffi::c_uchar, c: ::core::ffi::c_uchar);
}
extern "C" {
    #[doc = " \\m65libsummary{cputncxy}{Output N copies of a single character at X,Y coordinates}"]
    #[doc = "\\m65libsyntax    {void cputncxy (unsigned char x, unsigned char y, unsigned char count, unsigned char c)}"]
    #[doc = "\\m65libparam     {x}{The X coordinate where character will be printed}"]
    #[doc = "\\m65libparam     {y}{The Y coordinate where character will be printed}"]
    #[doc = "\\m65libparam     {count}{The number of characters to output}"]
    #[doc = "\\m65libparam     {c}{The screen code of the characters to print}"]
    pub fn cputncxy(
        x: ::core::ffi::c_uchar,
        y: ::core::ffi::c_uchar,
        count: ::core::ffi::c_uchar,
        c: ::core::ffi::c_uchar,
    );
}
extern "C" {
    pub fn _cprintf(
        translateCodes: ::core::ffi::c_uchar,
        fmt: *const ::core::ffi::c_uchar,
        ...
    ) -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{cgetc}{ Waits until a character is in the keyboard buffer and returns it }"]
    #[doc = "\\m65libsyntax    {unsigned char cgetc (void);}"]
    #[doc = "\\m65libretval    {The last character in the keyboard buffer }"]
    #[doc = "\\m65libremarks   {Returned values are ASCII character codes}"]
    pub fn cgetc() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{kbhit}{ Returns the character in the keyboard buffer }"]
    #[doc = "\\m65libsyntax    {unsigned char kbhit (void);}"]
    #[doc = "\\m65libretval    {The character code in the keyboard buffer,  0 otherwise. }"]
    #[doc = "\\m65libremarks   {Returned values are ASCII character codes}"]
    pub fn kbhit() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{getkeymodstate}{"]
    #[doc = "Return the key modifiers state.}"]
    #[doc = "\\m65libsyntax    {unsigned char getkeymodstate(void)}"]
    #[doc = "\\m65libretval    {A byte with the key modifier state bits,"]
    #[doc = "where bits:"]
    #[doc = "%<"]
    #[doc = "\\begin{tabular}{lll}"]
    #[doc = "\\textbf{Bit} & \\textbf{Meaning} & \\textbf{Constant}        \\\\"]
    #[doc = "0   & Right SHIFT State & \\texttt{KEYMOD\\_RSHIFT} \\\\"]
    #[doc = "1   & Left  SHIFT state & \\texttt{KEYMOD\\_LSHIFT} \\\\"]
    #[doc = "2   & CTRL state        & \\texttt{KEYMOD\\_CTRL}  \\\\"]
    #[doc = "3   & MEGA state        & \\texttt{KEYMOD\\_MEGA} \\\\"]
    #[doc = "4   & ALT state         & \\texttt{KEYMOD\\_ALT} \\\\"]
    #[doc = "5   & NOSCRL state      & \\texttt{KEYMOD\\_NOSCRL} \\\\"]
    #[doc = "6   & CAPSLOCK state    & \\texttt{KEYMOD\\_CAPSLOCK} \\\\"]
    #[doc = "7   & Reserved          & - \\\\"]
    #[doc = "\\end{tabular}"]
    #[doc = "%>}"]
    pub fn getkeymodstate() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{flushkeybuf}{Flush the keyboard buffer}"]
    #[doc = "\\m65libsyntax    {void flushkeybuf(void)}"]
    pub fn flushkeybuf();
}
extern "C" {
    #[doc = " \\m65libsummary{cinput}{Get input from keyboard, printing incoming characters at current position.}"]
    #[doc = "\\m65libsyntax    {unsigned char cinput(char* buffer, unsigned char buflen, unsigned char flags)}"]
    #[doc = "\\m65libparam     {buffer}{Target character buffer preallocated by caller}"]
    #[doc = "\\m65libparam     {buflen}{Target buffer length in characters, including the null character terminator}"]
    #[doc = "\\m65libparam     {flags}{Flags for input:  (default is accept all printable characters)"]
    #[doc = "%<"]
    #[doc = "\\texttt{CINPUT\\_ACCEPT\\_NUMERIC} \\\\"]
    #[doc = "Accepts numeric characters. \\\\ \\\\"]
    #[doc = "\\texttt{CINPUT\\_ACCEPT\\_LETTER}  \\\\"]
    #[doc = "Accepts letters.  \\\\ \\\\"]
    #[doc = "\\texttt{CINPUT\\_ACCEPT\\_SYM}  \\\\"]
    #[doc = "Accepts symbols.  \\\\ \\\\"]
    #[doc = "\\texttt{CINPUT\\_ACCEPT\\_ALL}\\\\"]
    #[doc = "Accepts all. Equals to \\texttt{CINPUT\\_ACCEPT\\_NUMERIC \\textbar CINPUT\\_ACCEPT\\_LETTER \\textbar"]
    #[doc = "CINPUT\\_ACCEPT\\_SYM} \\\\ \\\\"]
    #[doc = "\\texttt{CINPUT\\_ACCEPT\\_ALPHA} \\\\"]
    #[doc = "Accepts alphanumeric characters. Equals to \\texttt{CINPUT\\_ACCEPT\\_NUMERIC \\textbar CINPUT\\_ACCEPT\\_LETTER} \\\\ \\\\"]
    #[doc = "\\texttt{CINPUT\\_NO\\_AUTOTRANSLATE}\\\\"]
    #[doc = "Disables the feature that makes cinput to autodisplay uppercase characters when standard lowercase character set"]
    #[doc = "is selected  and the user enters letters without the SHIFT key, that would display graphic characters instead of"]
    #[doc = "alphabetic ones. \\\\"]
    #[doc = "%>}"]
    #[doc = ""]
    #[doc = "\\m65libretval    {Count of successfully read characters in buffer}"]
    pub fn cinput(
        buffer: *mut ::core::ffi::c_uchar,
        buflen: ::core::ffi::c_uchar,
        flags: ::core::ffi::c_uchar,
    ) -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn debug_msg(m: *mut ::core::ffi::c_char);
}
pub type int_least64_t = i64;
pub type uint_least64_t = u64;
pub type int_fast64_t = i64;
pub type uint_fast64_t = u64;
pub type int_least32_t = i32;
pub type uint_least32_t = u32;
pub type int_fast32_t = i32;
pub type uint_fast32_t = u32;
pub type int_least16_t = i16;
pub type uint_least16_t = u16;
pub type int_fast16_t = i16;
pub type uint_fast16_t = u16;
pub type int_least8_t = i8;
pub type uint_least8_t = u8;
pub type int_fast8_t = i8;
pub type uint_fast8_t = u8;
pub type intmax_t = ::core::ffi::c_longlong;
pub type uintmax_t = ::core::ffi::c_ulonglong;
extern "C" {
    pub fn opendir() -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn readdir(arg1: ::core::ffi::c_uchar) -> *mut m65_dirent;
}
extern "C" {
    pub fn closedir(arg1: ::core::ffi::c_uchar);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct m65_dirent {
    pub d_ino: u32,
    pub d_off: u16,
    pub d_reclen: u32,
    pub d_type: u16,
    pub d_name: [::core::ffi::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_m65_dirent() {
    assert_eq!(
        ::core::mem::size_of::<m65_dirent>(),
        268usize,
        concat!("Size of: ", stringify!(m65_dirent))
    );
    assert_eq!(
        ::core::mem::align_of::<m65_dirent>(),
        2usize,
        concat!("Alignment of ", stringify!(m65_dirent))
    );
    fn test_field_d_ino() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<m65_dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).d_ino) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(m65_dirent),
                "::",
                stringify!(d_ino)
            )
        );
    }
    test_field_d_ino();
    fn test_field_d_off() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<m65_dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).d_off) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(m65_dirent),
                "::",
                stringify!(d_off)
            )
        );
    }
    test_field_d_off();
    fn test_field_d_reclen() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<m65_dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).d_reclen) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(m65_dirent),
                "::",
                stringify!(d_reclen)
            )
        );
    }
    test_field_d_reclen();
    fn test_field_d_type() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<m65_dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).d_type) as usize - ptr as usize
            },
            10usize,
            concat!(
                "Offset of field: ",
                stringify!(m65_dirent),
                "::",
                stringify!(d_type)
            )
        );
    }
    test_field_d_type();
    fn test_field_d_name() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<m65_dirent>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).d_name) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(m65_dirent),
                "::",
                stringify!(d_name)
            )
        );
    }
    test_field_d_name();
}
impl Default for m65_dirent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn usleep(micros: u32);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct dmagic_dmalist {
    pub option_0b: ::core::ffi::c_uchar,
    pub option_80: ::core::ffi::c_uchar,
    pub source_mb: ::core::ffi::c_uchar,
    pub option_81: ::core::ffi::c_uchar,
    pub dest_mb: ::core::ffi::c_uchar,
    pub option_85: ::core::ffi::c_uchar,
    pub dest_skip: ::core::ffi::c_uchar,
    pub end_of_options: ::core::ffi::c_uchar,
    pub command: ::core::ffi::c_uchar,
    pub count: ::core::ffi::c_uint,
    pub source_addr: ::core::ffi::c_uint,
    pub source_bank: ::core::ffi::c_uchar,
    pub dest_addr: ::core::ffi::c_uint,
    pub dest_bank: ::core::ffi::c_uchar,
    pub sub_cmd: ::core::ffi::c_uchar,
    pub modulo: ::core::ffi::c_uint,
}
#[test]
fn bindgen_test_layout_dmagic_dmalist() {
    assert_eq!(
        ::core::mem::size_of::<dmagic_dmalist>(),
        20usize,
        concat!("Size of: ", stringify!(dmagic_dmalist))
    );
    assert_eq!(
        ::core::mem::align_of::<dmagic_dmalist>(),
        1usize,
        concat!("Alignment of ", stringify!(dmagic_dmalist))
    );
    fn test_field_option_0b() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).option_0b) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(option_0b)
            )
        );
    }
    test_field_option_0b();
    fn test_field_option_80() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).option_80) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(option_80)
            )
        );
    }
    test_field_option_80();
    fn test_field_source_mb() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).source_mb) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(source_mb)
            )
        );
    }
    test_field_source_mb();
    fn test_field_option_81() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).option_81) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(option_81)
            )
        );
    }
    test_field_option_81();
    fn test_field_dest_mb() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).dest_mb) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(dest_mb)
            )
        );
    }
    test_field_dest_mb();
    fn test_field_option_85() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).option_85) as usize - ptr as usize
            },
            5usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(option_85)
            )
        );
    }
    test_field_option_85();
    fn test_field_dest_skip() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).dest_skip) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(dest_skip)
            )
        );
    }
    test_field_dest_skip();
    fn test_field_end_of_options() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).end_of_options) as usize - ptr as usize
            },
            7usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(end_of_options)
            )
        );
    }
    test_field_end_of_options();
    fn test_field_command() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).command) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(command)
            )
        );
    }
    test_field_command();
    fn test_field_count() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).count) as usize - ptr as usize
            },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(count)
            )
        );
    }
    test_field_count();
    fn test_field_source_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).source_addr) as usize - ptr as usize
            },
            11usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(source_addr)
            )
        );
    }
    test_field_source_addr();
    fn test_field_source_bank() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).source_bank) as usize - ptr as usize
            },
            13usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(source_bank)
            )
        );
    }
    test_field_source_bank();
    fn test_field_dest_addr() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).dest_addr) as usize - ptr as usize
            },
            14usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(dest_addr)
            )
        );
    }
    test_field_dest_addr();
    fn test_field_dest_bank() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).dest_bank) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(dest_bank)
            )
        );
    }
    test_field_dest_bank();
    fn test_field_sub_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).sub_cmd) as usize - ptr as usize
            },
            17usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(sub_cmd)
            )
        );
    }
    test_field_sub_cmd();
    fn test_field_modulo() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<dmagic_dmalist>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).modulo) as usize - ptr as usize
            },
            18usize,
            concat!(
                "Offset of field: ",
                stringify!(dmagic_dmalist),
                "::",
                stringify!(modulo)
            )
        );
    }
    test_field_modulo();
}
extern "C" {
    pub static mut dmalist: dmagic_dmalist;
}
extern "C" {
    pub static mut dma_byte: ::core::ffi::c_uchar;
}
extern "C" {
    pub fn mega65_io_enable();
}
extern "C" {
    pub fn lpeek(address: ::core::ffi::c_long) -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn lpeek_debounced(address: ::core::ffi::c_long) -> ::core::ffi::c_uchar;
}
extern "C" {
    pub fn lpoke(address: ::core::ffi::c_long, value: ::core::ffi::c_uchar);
}
extern "C" {
    pub fn lcopy(
        source_address: ::core::ffi::c_long,
        destination_address: ::core::ffi::c_long,
        count: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn lfill(
        destination_address: ::core::ffi::c_long,
        value: ::core::ffi::c_uchar,
        count: ::core::ffi::c_uint,
    );
}
extern "C" {
    pub fn lfill_skip(
        destination_address: ::core::ffi::c_long,
        value: ::core::ffi::c_uchar,
        count: ::core::ffi::c_uint,
        skip: ::core::ffi::c_uchar,
    );
}
extern "C" {
    pub fn random32(range: u32) -> u32;
}
extern "C" {
    pub fn random16(range: u16) -> u16;
}
extern "C" {
    pub fn random8(range: u8) -> u8;
}
extern "C" {
    pub fn srand(seed: u32);
}
extern "C" {
    pub fn rand8(range: u8) -> u8;
}
extern "C" {
    pub fn rand16(range: u16) -> u16;
}
extern "C" {
    pub fn rand32(range: u32) -> u32;
}
extern "C" {
    pub static mut sector_buffer: [u8; 512usize];
}
extern "C" {
    pub fn mega65_clear_sector_buffer();
}
extern "C" {
    pub fn mega65_sdcard_reset();
}
extern "C" {
    pub fn mega65_fast();
}
extern "C" {
    pub fn mega65_sdcard_open();
}
extern "C" {
    pub fn mega65_sdcard_map_sector_buffer();
}
extern "C" {
    pub fn mega65_sdcard_unmap_sector_buffer();
}
extern "C" {
    pub fn mega65_sdcard_readsector(sector_number: u32) -> u8;
}
extern "C" {
    pub fn mega65_sdcard_writesector(sector_number: u32) -> u8;
}
extern "C" {
    pub fn mega65_sdcard_erase(first_sector: u32, last_sector: u32);
}
extern "C" {
    pub fn detect_target() -> ::core::ffi::c_uchar;
}
extern "C" {
    #[doc = " \\m65libsummary{unit_test_setup}{Setup of the unit test reporting to the host machine}"]
    #[doc = "\\m65libsyntax    {void unit_test_setup(char *testName, unsigned short issueNum);}"]
    #[doc = "\\m65libparam     {testName}{Human readable name of the test}"]
    #[doc = "\\m65libparam     {issueNum}{The mega65-core issue number that identifies the test issue}"]
    pub fn unit_test_setup(testName: *mut ::core::ffi::c_char, issueNum: ::core::ffi::c_ushort);
}
extern "C" {
    #[doc = " \\m65libsummary{unit_test_ok}{Report a successful test with a optional message}"]
    #[doc = "\\m65libsyntax    {void unit_test_ok(char *msg);}"]
    #[doc = "\\m65libparam     {msg}{Description of the successful test (NULL uses global testName)}"]
    pub fn unit_test_ok(msg: *mut ::core::ffi::c_char);
}
extern "C" {
    #[doc = " \\m65libsummary{unit_test_fail}{Report a failed test with a optional message}"]
    #[doc = "\\m65libsyntax    {void unit_test_fail(char *msg);}"]
    #[doc = "\\m65libparam     {msg}{Description of the failed test (NULL uses global testName)}"]
    pub fn unit_test_fail(msg: *mut ::core::ffi::c_char);
}
extern "C" {
    #[doc = " \\m65libsummary{unit_test_done}{Finish test procedure and tell m65 to exit}"]
    #[doc = "\\m65libsyntax    {void unit_test_done(void);}"]
    pub fn unit_test_done();
}
extern "C" {
    #[doc = " \\m65libsummary{unit_test_report}{Reports unit test result to the host machine}"]
    #[doc = "\\m65libsyntax    {void unit_test_report(unsigned short issue, unsigned char sub, unsigned char status);}"]
    #[doc = "\\m65libparam     {issue}{The issue number that identifies the test issue}"]
    #[doc = "\\m65libparam     {sub}{The sub issue number (for multiple tests per issue)}"]
    #[doc = "\\m65libparam     {status}{The test status to be sent}"]
    pub fn unit_test_report(
        issue: ::core::ffi::c_ushort,
        sub: ::core::ffi::c_uchar,
        status: ::core::ffi::c_uchar,
    );
}
extern "C" {
    #[doc = " \\m65libsummary{unit_test_set_current_name}{Reports current test name to the host machine}"]
    #[doc = "\\m65libsyntax    {void unit_test_set_current_name(char *name);}"]
    #[doc = "\\m65libparam     {name}{The human-readable name of the current test}"]
    pub fn unit_test_set_current_name(name: *mut ::core::ffi::c_char);
}
extern "C" {
    #[doc = " \\m65libsummary{unit_test_log}{Logs a message on the host machine}"]
    #[doc = "\\m65libsyntax    {void unit_test_log(char *msg);}"]
    #[doc = "\\m65libparam     {msg}{The message to be logged}"]
    pub fn unit_test_log(msg: *mut ::core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct m65_tm {
    pub tm_sec: ::core::ffi::c_uchar,
    pub tm_min: ::core::ffi::c_uchar,
    pub tm_hour: ::core::ffi::c_uchar,
    pub tm_mday: ::core::ffi::c_uchar,
    pub tm_mon: ::core::ffi::c_uchar,
    pub tm_year: ::core::ffi::c_ushort,
    pub tm_wday: ::core::ffi::c_uchar,
    pub tm_yday: ::core::ffi::c_int,
    pub tm_isdst: ::core::ffi::c_uchar,
}
#[test]
fn bindgen_test_layout_m65_tm() {
    assert_eq!(
        ::core::mem::size_of::<m65_tm>(),
        12usize,
        concat!("Size of: ", stringify!(m65_tm))
    );
    assert_eq!(
        ::core::mem::align_of::<m65_tm>(),
        2usize,
        concat!("Alignment of ", stringify!(m65_tm))
    );
    fn test_field_tm_sec() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<m65_tm>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(m65_tm),
                "::",
                stringify!(tm_sec)
            )
        );
    }
    test_field_tm_sec();
    fn test_field_tm_min() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<m65_tm>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(m65_tm),
                "::",
                stringify!(tm_min)
            )
        );
    }
    test_field_tm_min();
    fn test_field_tm_hour() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<m65_tm>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(m65_tm),
                "::",
                stringify!(tm_hour)
            )
        );
    }
    test_field_tm_hour();
    fn test_field_tm_mday() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<m65_tm>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize
            },
            3usize,
            concat!(
                "Offset of field: ",
                stringify!(m65_tm),
                "::",
                stringify!(tm_mday)
            )
        );
    }
    test_field_tm_mday();
    fn test_field_tm_mon() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<m65_tm>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(m65_tm),
                "::",
                stringify!(tm_mon)
            )
        );
    }
    test_field_tm_mon();
    fn test_field_tm_year() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<m65_tm>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize
            },
            6usize,
            concat!(
                "Offset of field: ",
                stringify!(m65_tm),
                "::",
                stringify!(tm_year)
            )
        );
    }
    test_field_tm_year();
    fn test_field_tm_wday() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<m65_tm>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(m65_tm),
                "::",
                stringify!(tm_wday)
            )
        );
    }
    test_field_tm_wday();
    fn test_field_tm_yday() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<m65_tm>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize
            },
            9usize,
            concat!(
                "Offset of field: ",
                stringify!(m65_tm),
                "::",
                stringify!(tm_yday)
            )
        );
    }
    test_field_tm_yday();
    fn test_field_tm_isdst() {
        assert_eq!(
            unsafe {
                let uninit = ::core::mem::MaybeUninit::<m65_tm>::uninit();
                let ptr = uninit.as_ptr();
                ::core::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize
            },
            11usize,
            concat!(
                "Offset of field: ",
                stringify!(m65_tm),
                "::",
                stringify!(tm_isdst)
            )
        );
    }
    test_field_tm_isdst();
}
extern "C" {
    pub fn getrtc(tm: *mut m65_tm);
}
extern "C" {
    pub fn setrtc(tm: *mut m65_tm);
}
